package graphics;

import flixel.FlxSprite;
import flixel.FlxG;
import flixel.animation.FlxAnimationController;
import flixel.graphics.frames.FlxAtlasFrames;
import flixel.util.FlxSignal.FlxTypedSignal;

/**
 * Replacement for flxanimate-based FlxAtlasSprite.
 * Uses FlxSprite + FlxAtlasFrames ONLY.
 */
class FlxAtlasSprite extends FlxSprite {
	/** Signal fired when animation starts. */
	public var onStart:FlxTypedSignal<String->Void> = new FlxTypedSignal<String->Void>();

	/** Path used for atlas loading (optional). */
	public var atlasPath:String = "";

	public function new(x:Float = 0, y:Float = 0, ?path:String) {
		super(x, y);
		if (path != null)
			loadAtlas(path);
	}

	/**
	 * Load a Sparrow / Atlas folder generated by your exporter.
	 * Expects:
	 *   atlas.png
	 *   atlas.xml
	 */
	public function loadAtlas(path:String) {
		atlasPath = path;

		var frames:FlxAtlasFrames = FlxAtlasFrames.fromSparrow('${path}.png', '${path}.xml');

		if (frames == null) {
			FlxG.log.error('Atlas load failed at path: $path');
			return;
		}

		this.frames = frames;
		this.animation = new FlxAnimationController(this);

		// Default animation if any prefix exists
		if (frames.frames.length > 0)
			this.animation.addByPrefix("idle", "", 24, true);
	}

	/**
	 * Adds animation by prefix (default FNF style).
	 */
	public function addByPrefix(name:String, prefix:String, frameRate:Int = 24, loop:Bool = true) {
		animation.addByPrefix(name, prefix, frameRate, loop);
	}

	/**
	 * Adds animation by manual indices.
	 */
	public function addByIndices(name:String, prefix:String, indices:Array<Int>, frameRate:Int = 24, loop:Bool = true) {
		animation.addByIndices(name, prefix, indices, frameRate, loop);
	}

	/**
	 * Remove animation.
	 */
	public function remove(name:String):Bool {
		return animation._animations.remove(name);
	}

	/**
	 * Play animation.
	 */
	public function playAnimation(name:String, force:Bool = false, reversed:Bool = false, startFrame:Int = 0) {
		if (!animation.exists(name)) {
			FlxG.log.warn('Animation "$name" does not exist.');
			return;
		}

		animation.play(name, force, reversed, startFrame);
		onStart.dispatch(name);
	}

	/**
	 * Pause.
	 */
	public function pause() {
		animation.pause();
	}

	/**
	 * Resume.
	 */
	public function resume() {
		animation.resume();
	}

	/**
	 * List of animation names.
	 */
	public var animations(get, null):Array<String>;

	function get_animations():Array<String> {
		return animation.getAnimationList();
	}

	/**
	 * Current animation name.
	 */
	public var curAnimName(get, null):String;

	function get_curAnimName():String {
		return animation.curAnim != null ? animation.curAnim.name : "";
	}

	/**
	 * Whether animation exists.
	 */
	public inline function animationExists(name:String):Bool {
		return animation.exists(name);
	}
}
